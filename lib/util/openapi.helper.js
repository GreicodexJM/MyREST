'use strict';

/**
 * Maps MySQL data types to OpenAPI types
 */
function mapType(mysqlType) {
    const type = mysqlType.toLowerCase();
    if (type.includes('int')) return 'integer';
    if (type.includes('dec') || type.includes('float') || type.includes('double')) return 'number';
    if (type.includes('bool')) return 'boolean';
    return 'string';
}

exports.generate = function(metaDb, hostBaseUrl) {
    let spec = {
        openapi: '3.0.0',
        info: {
            title: 'myrest generated API',
            version: '1.0.0',
            description: 'REST API generated by myrest'
        },
        servers: [
            {
                url: hostBaseUrl
            }
        ],
        paths: {},
        components: {
            schemas: {},
            securitySchemes: {
                bearerAuth: {
                    type: 'http',
                    scheme: 'bearer',
                    bearerFormat: 'JWT'
                }
            }
        },
        security: [{
            bearerAuth: []
        }]
    };

    // 1. Generate Schemas and Paths for Tables
    for (const tableName in metaDb.tables) {
        const table = metaDb.tables[tableName];
        const schemaName = tableName;
        
        // Define Schema
        let properties = {};
        let required = [];
        
        table.columns.forEach(col => {
            properties[col.column_name] = {
                type: mapType(col.data_type),
                description: col.column_type
            };
            if (col.is_nullable === 'NO' && col.column_default === null && col.column_key !== 'PRI') { // Simple heuristic
                required.push(col.column_name);
            }
        });

        spec.components.schemas[schemaName] = {
            type: 'object',
            properties: properties
        };

        // Define Paths
        // Collection /tableName
        spec.paths[`/${tableName}`] = {
            get: {
                summary: `List ${tableName}`,
                responses: {
                    '200': {
                        description: `Array of ${tableName}`,
                        content: {
                            'application/json': {
                                schema: {
                                    type: 'array',
                                    items: {
                                        $ref: `#/components/schemas/${schemaName}`
                                    }
                                }
                            }
                        }
                    }
                }
            },
            post: {
                summary: `Create ${tableName}`,
                requestBody: {
                    content: {
                        'application/json': {
                            schema: {
                                $ref: `#/components/schemas/${schemaName}`
                            }
                        }
                    }
                },
                responses: {
                    '200': { description: 'Created' },
                    '201': { description: 'Created' }
                }
            }
        };

        // Single Item /tableName/{id}
        // Need to identify PK name. Assuming single PK for simplicity or using ID param generic
        spec.paths[`/${tableName}/{id}`] = {
            get: {
                summary: `Read ${tableName} by ID`,
                parameters: [{
                    name: 'id',
                    in: 'path',
                    required: true,
                    schema: { type: 'string' }
                }],
                responses: {
                    '200': {
                        description: `Single ${tableName}`,
                        content: {
                            'application/json': {
                                schema: { $ref: `#/components/schemas/${schemaName}` }
                            }
                        }
                    }
                }
            },
            patch: {
                summary: `Update ${tableName}`,
                parameters: [{
                    name: 'id',
                    in: 'path',
                    required: true,
                    schema: { type: 'string' }
                }],
                requestBody: {
                    content: {
                        'application/json': {
                            schema: { $ref: `#/components/schemas/${schemaName}` }
                        }
                    }
                },
                responses: { '200': { description: 'Updated' } }
            },
            delete: {
                summary: `Delete ${tableName}`,
                parameters: [{
                    name: 'id',
                    in: 'path',
                    required: true,
                    schema: { type: 'string' }
                }],
                responses: { '200': { description: 'Deleted' } }
            }
        };
    }

    // 2. Generate Paths for RPC (Stored Procedures)
    for (const procName in metaDb.routines) {
        const routine = metaDb.routines[procName];
        
        let properties = {};
        routine.params.forEach(p => {
            properties[p.name] = {
                type: mapType(p.type)
            };
        });

        spec.paths[`/rpc/${procName}`] = {
            post: {
                summary: `Call ${procName}`,
                requestBody: {
                    content: {
                        'application/json': {
                            schema: {
                                type: 'object',
                                properties: properties
                            }
                        }
                    }
                },
                responses: {
                    '200': {
                        description: 'Result',
                        content: {
                            'application/json': {
                                schema: { type: 'object' } // Dynamic result
                            }
                        }
                    }
                }
            }
        };
    }

    return spec;
};
